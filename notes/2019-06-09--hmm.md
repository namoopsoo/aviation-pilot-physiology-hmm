

#### try to make the output data pure numpy array not an array of arrays!
```python


def make_data(df, crews={'training': [1],
                        'test': [2]},
              sequence_window=256, percent_of_data=100,
             feature_cols={'r': 'standard_scaler'}):

    # current sorted as ['crew', 'experiment', 'time']
    [0, 1] # each seat
    ['CA', 'DA', 'SS'] # experiment
    
    sort_cols = ['crew', 'seat', 'experiment', 'time']
    target_col = 'event'
    
    what_cols = sort_cols + list(feature_cols) + [target_col]

    # Training
    traindf = df[df.crew.isin(crews['training'])][what_cols].sort_values(
        by=sort_cols).copy()
    
    scalar_dict, _ = do_standard_scaling(traindf, ['r'])
    
    print('Start building training set', timestamp())
    x_train, y_train = get_windows(traindf, ['r_scaled', 'event'],
                                   sequence_window,
                                  percent_of_data=percent_of_data)
    
    # Testing
    testdf = df[df.crew.isin(crews['test'])][what_cols].sort_values(
        by=sort_cols).copy()

    _, _ = do_standard_scaling(testdf, ['r'], scalar_dict)
    
    
    print('Start building testing set', timestamp())
    x_test, y_test = get_windows(testdf, ['r_scaled', 'event'],
                                 sequence_window,
                                 percent_of_data=percent_of_data)


    outdata = {
        "x_train": x_train,
        "y_train": reshape_y(encode_class(y_train), 4), # y_train,
        "x_test": x_test,
        "y_test": reshape_y(encode_class(y_test), 4), # y_test
        "y_train_original": y_train,
        "y_test_original": y_test,
        "traindf": traindf,
        "testdf": testdf,}
    metadata = {
        "metadata": {
            "output": {
                "shapes": {k: outdata[k].shape for k in list(outdata)},
                "Counter(outdata['y_train_original'])":
                dict(Counter(y_train)),
                "Counter(outdata['y_test_original'])":
                dict(Counter(y_test)),},
            "input": {"kwargs": {
                "crews": crews,
                "percent_of_data": percent_of_data,
                "sequence_window": sequence_window,
                "feature_cols": list(feature_cols)}},
            "data_ts": timestamp()
        }}
            
    return {**outdata, **metadata}
    
    
def validate_data(data):
    assert len(Counter(data['y_train_original'])) > 1
    assert len(Counter(data['y_test_original'])) > 1
  
    
def get_windows(df, cols, window_size, percent_of_data=100):
    
    whats_proportion_index = lambda x, y: round(x*y)
    
    X = []
    Y = []
    choices = (df.crew.unique().tolist(), [0, 1], ['CA', 'DA', 'SS'])
    for crew, seat, experiment in itertools.product(*choices):
        query = (df.crew == crew)&(df.seat == seat)&(df.experiment == experiment)
        thisdf = df[query][cols]
        X_i, Y_i = to_sequences(thisdf.values, window_size)
        X.append(X_i[:
                     whats_proportion_index(
                         X_i.shape[0],
                         percent_of_data)])
        Y.append(Y_i[:
                     whats_proportion_index(
                        Y_i.shape[0],
                        percent_of_data)])
        
    return np.concatenate(X), np.concatenate(Y)

# Borrowing parts of this func from 
# https://github.com/jeffheaton/t81_558_deep_learning/blob/master/t81_558_class10_lstm.ipynb
def to_sequences(obs, seq_size, incols=[0], outcols=[1]):
    x = []
    y = []

    for i in range(len(obs)-seq_size-1):
        #print(i)
        window = obs[i:(i+seq_size)][..., 0]
        after_window = obs[i+seq_size, 1] # FIXME :off by 1 error here?
        # window = [[x] for x in window]

        x.append(window)
        y.append(after_window)
        
    xarr = np.array(x)
    yarr = np.array(y)
    return (np.resize(xarr, xarr.shape + (1,)),
            yarr)

```

